最终任务: 处理中间层的聚类在KSplitting.cs中的使用


优化计算RC时的速度

首先就是代码里已经有了CalculateClusterRC这个函数来计算负载，而且这个函数有2个使用，但是这里计算和CalculateBufferLoad 不一样，这个不对，计算负载需要的是这个聚类的中心点的缓冲器的距离和类中的其他元件的来算，这里为了给接下来的层数再聚类，有必要去把计算后的负载作为这个buffer的信息，这样buffer上的buffer就在本来的基础上在把个个的buffer加上，现在就是要把 CaluclateClusterRC和它用的地方去掉，这个计算应该是在中心点计算出来后在来检查而不是在检查最大扇出的时候一起检查了，



PlaceBuffer中使用了计算中心点，但是又检查了有没有重叠，要把这个函数分开，计算作为一个（添加处理底部和中部的函数的切换），然后在这层聚类完成后再去Place缓冲器

当前的代码在递归分裂和检查扇出数量时，可能会因为频繁地构建新聚类和不断增加的链表操作而导致内存和CPU占用过高。以下是几个优化建议，以减少内存使用并提高效率：

避免重复计算边集和MST：

在 SplitAndCheckCluster 和 SplitCluster 中，每次递归分裂时都在重新构建边集和最小生成树（MST）。可以在首次构建时将边集缓存，以便在多次分裂中重复使用，从而减少冗余计算。
考虑将 BuildSparseGraphForCluster 和 KruskalMST 返回的结果缓存到 Dictionary，使用 cluster 的哈希值作为键值。这样在后续递归中可以快速查询，而不是重新计算。
避免不必要的对象分配：

在每次分裂操作中，代码创建了许多新的 Edge 和 Node 对象。通过重用这些对象，您可以减少内存占用。例如，在 BuildSparseGraph 方法中，尽量在 Parallel.ForEach 外部预分配一个大的 List<Edge>，以避免每个线程锁定和内存分配的开销。
使用对象池（例如 ConcurrentBag 或自定义对象池）来管理 Edge 和 Node 对象的生命周期，以避免频繁的内存分配和释放。
限制递归深度：

在递归分裂操作时增加一个条件，检查分裂的收益。如果发现分裂后的聚类变化非常小，可以提前结束递归。例如，在 SplitAndCheckCluster 中，如果新分裂的聚类数目和节点数量与原始聚类相似，可以认为分裂不再有效，从而提前终止递归。
优化 KD 树的最近邻查找：

KDTree 的最近邻查找在大数据量下可能会变得缓慢。您可以考虑优化 KD 树的实现，使用分层缓存等方法以提高查找速度。同时，减少每次查询的节点数量（maxEdgesPerNode），控制每个聚类的边数，进一步优化查找效率。
减少链表插入和删除操作：

链表（LinkedList<List<Node>>）在频繁的插入、删除操作下会引起内存碎片化。可以考虑将链表替换为并发集合，例如 ConcurrentQueue 或 BlockingCollection，以便在并发场景下更高效地处理插入和删除操作。
如果链表操作是瓶颈，转而使用 List<List<Node>> 并仅在需要插入和删除时创建新的列表会更高效。
分割时减少图的构建开销：

在 SplitCluster 中，每次分割聚类时都会重新生成一张局部稀疏图。您可以尝试直接基于 MST 中的长边切割，而不重新构建新的稀疏图。在初始 MST 中标记长边，逐步去除长边形成子图，从而避免重复生成 MST。
分治法减少递归子问题规模：

对于大规模聚类，可以使用分治法将问题拆分为更小的部分，针对每个小部分独立处理。这样可以减少每次聚类对象的规模，避免在单个方法中处理太多数据。此外，可以先对整个问题空间做预聚类，将大空间划分为若干子空间，并独立执行 SplitAndCheckCluster，最后合并结果。